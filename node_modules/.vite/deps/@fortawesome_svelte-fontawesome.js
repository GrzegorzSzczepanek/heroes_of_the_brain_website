import {
  icon,
  parse$1
} from "./chunk-FHKPYISU.js";
import "./chunk-SA3VOP2B.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  assign,
  bind,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_html_tag,
  claim_svg_element,
  compute_rest_props,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  exclude_internal_props,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  set_svg_attributes,
  svg_element,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-K6FPUMXB.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-TYRVL62N.js";

// node_modules/@fortawesome/svelte-fontawesome/src/utils/get-class-list-from-props.js
function classList(props) {
  const {
    beat,
    fade,
    beatFade,
    bounce,
    shake,
    flash,
    spin,
    spinPulse,
    spinReverse,
    pulse,
    fixedWidth,
    inverse,
    border,
    listItem,
    flip,
    size,
    rotation,
    pull
  } = props;
  const classes = {
    "fa-beat": beat,
    "fa-fade": fade,
    "fa-beat-fade": beatFade,
    "fa-bounce": bounce,
    "fa-shake": shake,
    "fa-flash": flash,
    "fa-spin": spin,
    "fa-spin-reverse": spinReverse,
    "fa-spin-pulse": spinPulse,
    "fa-pulse": pulse,
    "fa-fw": fixedWidth,
    "fa-inverse": inverse,
    "fa-border": border,
    "fa-li": listItem,
    "fa-flip": flip === true,
    "fa-flip-horizontal": flip === "horizontal" || flip === "both",
    "fa-flip-vertical": flip === "vertical" || flip === "both",
    [`fa-${size}`]: typeof size !== "undefined" && size !== null,
    [`fa-rotate-${rotation}`]: typeof rotation !== "undefined" && rotation !== null && rotation !== 0,
    [`fa-pull-${pull}`]: typeof pull !== "undefined" && pull !== null,
    "fa-swap-opacity": props.swapOpacity
  };
  return Object.keys(classes).map((key) => classes[key] ? key : null).filter((key) => key);
}

// node_modules/@fortawesome/svelte-fontawesome/src/utils/camelize.js
function _isNumerical(obj) {
  obj = obj - 0;
  return obj === obj;
}
function camelize(string) {
  if (_isNumerical(string)) {
    return string;
  }
  string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
    return chr ? chr.toUpperCase() : "";
  });
  return string.substr(0, 1).toLowerCase() + string.substr(1);
}

// node_modules/@fortawesome/svelte-fontawesome/src/converter.js
function styleToString(style) {
  if (typeof style === "string") {
    return style;
  }
  return Object.keys(style).reduce((acc, key) => acc + key.split(/(?=[A-Z])/).join("-").toLowerCase() + ":" + style[key] + ";", "");
}
function convert(createElement, element, extraProps = {}) {
  if (typeof element === "string") {
    return element;
  }
  const children2 = (element.children || []).map((child) => {
    return convert(createElement, child);
  });
  const mixins = Object.keys(element.attributes || {}).reduce(
    (acc, key) => {
      const val = element.attributes[key];
      if (key === "style") {
        acc.attrs["style"] = styleToString(val);
      } else {
        if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }
      }
      return acc;
    },
    { attrs: {} }
  );
  return createElement(element.tag, { ...mixins.attrs }, children2);
}
var converter_default = convert;

// node_modules/@fortawesome/svelte-fontawesome/src/logger.js
var PRODUCTION = false;
try {
  PRODUCTION = false;
} catch (e) {
}
function logger_default(...args) {
  if (!PRODUCTION && console && typeof console.error === "function") {
    console.error(...args);
  }
}

// node_modules/@fortawesome/svelte-fontawesome/src/utils/normalize-icon-args.js
function normalizeIconArgs(icon2) {
  if (icon2 && typeof icon2 === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse$1.icon) {
    return parse$1.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (icon2 && typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return { prefix: icon2[0], iconName: icon2[1] };
  }
  if (typeof icon2 === "string") {
    return { prefix: "fas", iconName: icon2 };
  }
}

// node_modules/@fortawesome/svelte-fontawesome/src/utils/object-with-key.js
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? { [key]: value } : {};
}

// node_modules/@fortawesome/svelte-fontawesome/src/components/SvgElement.svelte
var { Error: Error_1, Object: Object_1 } = globals;
var file = "node_modules/@fortawesome/svelte-fontawesome/src/components/SvgElement.svelte";
function create_fragment(ctx) {
  let svg;
  let html_tag;
  let svg_levels = [
    /*elementProps*/
    ctx[2]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      html_tag = new HtmlTagHydration(true);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {});
      var svg_nodes = children(svg);
      html_tag = claim_html_tag(svg_nodes, true);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 32, 0, 860);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      html_tag.m(
        /*markup*/
        ctx[1],
        svg
      );
      ctx[7](svg);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvgElement", slots, []);
  let { tag } = $$props;
  let { props } = $$props;
  let { children: children2 } = $$props;
  let { style = null } = $$props;
  let { ref = null } = $$props;
  if (tag !== "svg") {
    throw new Error('SvgElement requires a tag of "svg"');
  }
  function processChildren(children3) {
    return (children3 == null ? void 0 : children3.reduce(
      (acc, child) => {
        return acc + (child.tag ? generateMarkup(child) : child);
      },
      ""
    )) || "";
  }
  function generateMarkup({ tag: tag2, props: props2, children: children3 }) {
    const attributes = Object.keys(props2).map((key) => `${key}="${props2[key]}"`).join(" ");
    return `<${tag2} ${attributes}>${processChildren(children3)}</${tag2}>`;
  }
  const markup = processChildren(children2);
  const elementStyle = (props == null ? void 0 : props.style) ? `${props.style}${style || ""}` : style;
  const elementProps = { ...props, style: elementStyle };
  $$self.$$.on_mount.push(function() {
    if (tag === void 0 && !("tag" in $$props || $$self.$$.bound[$$self.$$.props["tag"]])) {
      console.warn("<SvgElement> was created without expected prop 'tag'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<SvgElement> was created without expected prop 'props'");
    }
    if (children2 === void 0 && !("children" in $$props || $$self.$$.bound[$$self.$$.props["children"]])) {
      console.warn("<SvgElement> was created without expected prop 'children'");
    }
  });
  const writable_props = ["tag", "props", "children", "style", "ref"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SvgElement> was created with unknown prop '${key}'`);
  });
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tag" in $$props2)
      $$invalidate(3, tag = $$props2.tag);
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("children" in $$props2)
      $$invalidate(5, children2 = $$props2.children);
    if ("style" in $$props2)
      $$invalidate(6, style = $$props2.style);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
  };
  $$self.$capture_state = () => ({
    tag,
    props,
    children: children2,
    style,
    ref,
    processChildren,
    generateMarkup,
    markup,
    elementStyle,
    elementProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("tag" in $$props2)
      $$invalidate(3, tag = $$props2.tag);
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("children" in $$props2)
      $$invalidate(5, children2 = $$props2.children);
    if ("style" in $$props2)
      $$invalidate(6, style = $$props2.style);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, markup, elementProps, tag, props, children2, style, svg_binding];
}
var SvgElement = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      tag: 3,
      props: 4,
      children: 5,
      style: 6,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvgElement",
      options,
      id: create_fragment.name
    });
  }
  get tag() {
    throw new Error_1("<SvgElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error_1("<SvgElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error_1("<SvgElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error_1("<SvgElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error_1("<SvgElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error_1("<SvgElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<SvgElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<SvgElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error_1("<SvgElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error_1("<SvgElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvgElement_default = SvgElement;

// node_modules/@fortawesome/svelte-fontawesome/src/components/FontAwesomeIcon.svelte
function create_if_block(ctx) {
  let svgelement;
  let updating_ref;
  let current;
  const svgelement_spread_levels = [
    /*result*/
    ctx[2],
    { style: (
      /*style*/
      ctx[1]
    ) }
  ];
  function svgelement_ref_binding(value) {
    ctx[28](value);
  }
  let svgelement_props = {};
  for (let i = 0; i < svgelement_spread_levels.length; i += 1) {
    svgelement_props = assign(svgelement_props, svgelement_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    svgelement_props.ref = /*ref*/
    ctx[0];
  }
  svgelement = new SvgElement_default({ props: svgelement_props, $$inline: true });
  binding_callbacks.push(() => bind(svgelement, "ref", svgelement_ref_binding));
  const block = {
    c: function create() {
      create_component(svgelement.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svgelement.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svgelement, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgelement_changes = dirty[0] & /*result, style*/
      6 ? get_spread_update(svgelement_spread_levels, [
        dirty[0] & /*result*/
        4 && get_spread_object(
          /*result*/
          ctx2[2]
        ),
        dirty[0] & /*style*/
        2 && { style: (
          /*style*/
          ctx2[1]
        ) }
      ]) : {};
      if (!updating_ref && dirty[0] & /*ref*/
      1) {
        updating_ref = true;
        svgelement_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      svgelement.$set(svgelement_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgelement.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgelement.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svgelement, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(101:0) {#if result}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*result*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*result*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*result*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "border",
    "mask",
    "maskId",
    "fixedWidth",
    "inverse",
    "flip",
    "icon",
    "listItem",
    "pull",
    "pulse",
    "rotation",
    "size",
    "spin",
    "spinPulse",
    "spinReverse",
    "beat",
    "fade",
    "beatFade",
    "bounce",
    "shake",
    "symbol",
    "title",
    "titleId",
    "transform",
    "swapOpacity",
    "ref",
    "style"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FontAwesomeIcon", slots, []);
  let { border = false } = $$props;
  let { mask = null } = $$props;
  let { maskId = null } = $$props;
  let { fixedWidth = false } = $$props;
  let { inverse = false } = $$props;
  let { flip = false } = $$props;
  let { icon: icon2 = null } = $$props;
  let { listItem = false } = $$props;
  let { pull = null } = $$props;
  let { pulse = false } = $$props;
  let { rotation = null } = $$props;
  let { size = null } = $$props;
  let { spin = false } = $$props;
  let { spinPulse = false } = $$props;
  let { spinReverse = false } = $$props;
  let { beat = false } = $$props;
  let { fade = false } = $$props;
  let { beatFade = false } = $$props;
  let { bounce = false } = $$props;
  let { shake = false } = $$props;
  let { symbol = false } = $$props;
  let { title = "" } = $$props;
  let { titleId = null } = $$props;
  let { transform = null } = $$props;
  let { swapOpacity = false } = $$props;
  let { ref = null } = $$props;
  let { style = null } = $$props;
  const iconLookup = normalizeIconArgs(icon2);
  const classes = objectWithKey("classes", [...classList($$props), ...($$props.class || "").split(" ")]);
  const transformObj = objectWithKey("transform", typeof transform === "string" ? parse$1.transform(transform) : transform);
  const maskObj = objectWithKey("mask", normalizeIconArgs(mask));
  const renderedIcon = icon(iconLookup, {
    ...classes,
    ...transformObj,
    ...maskObj,
    symbol,
    title,
    titleId,
    maskId
  });
  let result = null;
  if (!renderedIcon) {
    logger_default("Could not find icon", iconLookup);
  } else {
    const { abstract } = renderedIcon;
    result = converter_default(
      (tag, props, children2) => {
        return { tag, props, children: children2 };
      },
      abstract[0],
      $$restProps
    );
  }
  function svgelement_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(35, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(34, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("border" in $$new_props)
      $$invalidate(3, border = $$new_props.border);
    if ("mask" in $$new_props)
      $$invalidate(4, mask = $$new_props.mask);
    if ("maskId" in $$new_props)
      $$invalidate(5, maskId = $$new_props.maskId);
    if ("fixedWidth" in $$new_props)
      $$invalidate(6, fixedWidth = $$new_props.fixedWidth);
    if ("inverse" in $$new_props)
      $$invalidate(7, inverse = $$new_props.inverse);
    if ("flip" in $$new_props)
      $$invalidate(8, flip = $$new_props.flip);
    if ("icon" in $$new_props)
      $$invalidate(9, icon2 = $$new_props.icon);
    if ("listItem" in $$new_props)
      $$invalidate(10, listItem = $$new_props.listItem);
    if ("pull" in $$new_props)
      $$invalidate(11, pull = $$new_props.pull);
    if ("pulse" in $$new_props)
      $$invalidate(12, pulse = $$new_props.pulse);
    if ("rotation" in $$new_props)
      $$invalidate(13, rotation = $$new_props.rotation);
    if ("size" in $$new_props)
      $$invalidate(14, size = $$new_props.size);
    if ("spin" in $$new_props)
      $$invalidate(15, spin = $$new_props.spin);
    if ("spinPulse" in $$new_props)
      $$invalidate(16, spinPulse = $$new_props.spinPulse);
    if ("spinReverse" in $$new_props)
      $$invalidate(17, spinReverse = $$new_props.spinReverse);
    if ("beat" in $$new_props)
      $$invalidate(18, beat = $$new_props.beat);
    if ("fade" in $$new_props)
      $$invalidate(19, fade = $$new_props.fade);
    if ("beatFade" in $$new_props)
      $$invalidate(20, beatFade = $$new_props.beatFade);
    if ("bounce" in $$new_props)
      $$invalidate(21, bounce = $$new_props.bounce);
    if ("shake" in $$new_props)
      $$invalidate(22, shake = $$new_props.shake);
    if ("symbol" in $$new_props)
      $$invalidate(23, symbol = $$new_props.symbol);
    if ("title" in $$new_props)
      $$invalidate(24, title = $$new_props.title);
    if ("titleId" in $$new_props)
      $$invalidate(25, titleId = $$new_props.titleId);
    if ("transform" in $$new_props)
      $$invalidate(26, transform = $$new_props.transform);
    if ("swapOpacity" in $$new_props)
      $$invalidate(27, swapOpacity = $$new_props.swapOpacity);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("style" in $$new_props)
      $$invalidate(1, style = $$new_props.style);
  };
  $$self.$capture_state = () => ({
    classList,
    convert: converter_default,
    coreIcon: icon,
    parse: parse$1,
    log: logger_default,
    normalizeIconArgs,
    objectWithKey,
    SvgElement: SvgElement_default,
    border,
    mask,
    maskId,
    fixedWidth,
    inverse,
    flip,
    icon: icon2,
    listItem,
    pull,
    pulse,
    rotation,
    size,
    spin,
    spinPulse,
    spinReverse,
    beat,
    fade,
    beatFade,
    bounce,
    shake,
    symbol,
    title,
    titleId,
    transform,
    swapOpacity,
    ref,
    style,
    iconLookup,
    classes,
    transformObj,
    maskObj,
    renderedIcon,
    result
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(35, $$props = assign(assign({}, $$props), $$new_props));
    if ("border" in $$props)
      $$invalidate(3, border = $$new_props.border);
    if ("mask" in $$props)
      $$invalidate(4, mask = $$new_props.mask);
    if ("maskId" in $$props)
      $$invalidate(5, maskId = $$new_props.maskId);
    if ("fixedWidth" in $$props)
      $$invalidate(6, fixedWidth = $$new_props.fixedWidth);
    if ("inverse" in $$props)
      $$invalidate(7, inverse = $$new_props.inverse);
    if ("flip" in $$props)
      $$invalidate(8, flip = $$new_props.flip);
    if ("icon" in $$props)
      $$invalidate(9, icon2 = $$new_props.icon);
    if ("listItem" in $$props)
      $$invalidate(10, listItem = $$new_props.listItem);
    if ("pull" in $$props)
      $$invalidate(11, pull = $$new_props.pull);
    if ("pulse" in $$props)
      $$invalidate(12, pulse = $$new_props.pulse);
    if ("rotation" in $$props)
      $$invalidate(13, rotation = $$new_props.rotation);
    if ("size" in $$props)
      $$invalidate(14, size = $$new_props.size);
    if ("spin" in $$props)
      $$invalidate(15, spin = $$new_props.spin);
    if ("spinPulse" in $$props)
      $$invalidate(16, spinPulse = $$new_props.spinPulse);
    if ("spinReverse" in $$props)
      $$invalidate(17, spinReverse = $$new_props.spinReverse);
    if ("beat" in $$props)
      $$invalidate(18, beat = $$new_props.beat);
    if ("fade" in $$props)
      $$invalidate(19, fade = $$new_props.fade);
    if ("beatFade" in $$props)
      $$invalidate(20, beatFade = $$new_props.beatFade);
    if ("bounce" in $$props)
      $$invalidate(21, bounce = $$new_props.bounce);
    if ("shake" in $$props)
      $$invalidate(22, shake = $$new_props.shake);
    if ("symbol" in $$props)
      $$invalidate(23, symbol = $$new_props.symbol);
    if ("title" in $$props)
      $$invalidate(24, title = $$new_props.title);
    if ("titleId" in $$props)
      $$invalidate(25, titleId = $$new_props.titleId);
    if ("transform" in $$props)
      $$invalidate(26, transform = $$new_props.transform);
    if ("swapOpacity" in $$props)
      $$invalidate(27, swapOpacity = $$new_props.swapOpacity);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("style" in $$props)
      $$invalidate(1, style = $$new_props.style);
    if ("result" in $$props)
      $$invalidate(2, result = $$new_props.result);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    ref,
    style,
    result,
    border,
    mask,
    maskId,
    fixedWidth,
    inverse,
    flip,
    icon2,
    listItem,
    pull,
    pulse,
    rotation,
    size,
    spin,
    spinPulse,
    spinReverse,
    beat,
    fade,
    beatFade,
    bounce,
    shake,
    symbol,
    title,
    titleId,
    transform,
    swapOpacity,
    svgelement_ref_binding
  ];
}
var FontAwesomeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        border: 3,
        mask: 4,
        maskId: 5,
        fixedWidth: 6,
        inverse: 7,
        flip: 8,
        icon: 9,
        listItem: 10,
        pull: 11,
        pulse: 12,
        rotation: 13,
        size: 14,
        spin: 15,
        spinPulse: 16,
        spinReverse: 17,
        beat: 18,
        fade: 19,
        beatFade: 20,
        bounce: 21,
        shake: 22,
        symbol: 23,
        title: 24,
        titleId: 25,
        transform: 26,
        swapOpacity: 27,
        ref: 0,
        style: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FontAwesomeIcon",
      options,
      id: create_fragment2.name
    });
  }
  get border() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mask() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mask(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskId() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskId(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixedWidth() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixedWidth(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listItem() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listItem(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pull() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pull(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spinPulse() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spinPulse(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spinReverse() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spinReverse(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beat() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beat(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beatFade() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beatFade(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bounce() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bounce(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shake() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shake(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get symbol() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set symbol(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleId() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleId(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transform() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swapOpacity() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swapOpacity(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<FontAwesomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<FontAwesomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FontAwesomeIcon_default = FontAwesomeIcon;
export {
  FontAwesomeIcon_default as FontAwesomeIcon
};
//# sourceMappingURL=@fortawesome_svelte-fontawesome.js.map
