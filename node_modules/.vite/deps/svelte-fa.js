import "./chunk-AYNHEKRI.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_svg_element,
  claim_text,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_hydration_dev,
  noop,
  safe_not_equal,
  set_data_dev,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-DCE4O3CF.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-V6TY7KAL.js";

// node_modules/svelte-fa/dist/utils.js
function setCustomFontSize(element2, size) {
  if (size && size !== "lg" && size !== "sm" && size !== "xs") {
    element2.style.fontSize = size.replace("x", "em");
  } else {
    element2.style.fontSize = "";
  }
}
function getTransform(scale, translateX, translateY, rotate, flip, translateTimes = 1, translateUnit = "", rotateUnit = "") {
  let flipX = 1;
  let flipY = 1;
  if (flip) {
    if (flip == "horizontal") {
      flipX = -1;
    } else if (flip == "vertical") {
      flipY = -1;
    } else {
      flipX = flipY = -1;
    }
  }
  if (typeof scale === "string") {
    scale = parseFloat(scale);
  }
  if (typeof translateX === "string") {
    translateX = parseFloat(translateX);
  }
  if (typeof translateY === "string") {
    translateY = parseFloat(translateY);
  }
  const x = `${translateX * translateTimes}${translateUnit}`;
  const y = `${translateY * translateTimes}${translateUnit}`;
  let output = `translate(${x},${y}) scale(${flipX * scale},${flipY * scale})`;
  if (rotate) {
    output += ` rotate(${rotate}${rotateUnit})`;
  }
  return output;
}

// node_modules/svelte-fa/dist/fa.svelte
var file = "node_modules/svelte-fa/dist/fa.svelte";
function add_css(target) {
  append_styles(target, "svelte-bvo74f", ".svelte-fa-base{height:1em;overflow:visible;transform-origin:center;vertical-align:-0.125em}.svelte-fa-fw{text-align:center;width:1.25em}.svelte-fa-pull-left.svelte-bvo74f{float:left}.svelte-fa-pull-right.svelte-bvo74f{float:right}.svelte-fa-size-lg.svelte-bvo74f{font-size:1.33333em;line-height:0.75em;vertical-align:-0.225em}.svelte-fa-size-sm.svelte-bvo74f{font-size:0.875em}.svelte-fa-size-xs.svelte-bvo74f{font-size:0.75em}.spin.svelte-bvo74f{animation:svelte-bvo74f-spin 2s 0s infinite linear}.pulse.svelte-bvo74f{animation:svelte-bvo74f-spin 1s infinite steps(8)}@keyframes svelte-bvo74f-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmEuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9nc2svaGVyb2VzX29mX3RoZV9icmFpbl93ZWJzaXRlL25vZGVfbW9kdWxlcy9zdmVsdGUtZmEvZGlzdC9mYS5zdmVsdGUiXX0= */");
}
function create_if_block(ctx) {
  let svg;
  let g1;
  let g0;
  let g1_transform_value;
  let g1_transform_origin_value;
  let svg_class_value;
  let svg_viewBox_value;
  let svg_aria_hidden_value;
  let if_block0 = (
    /*title*/
    ctx[3] && create_if_block_2(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (typeof /*i*/
    ctx2[17][4] == "string") return create_if_block_1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block0) if_block0.c();
      g1 = svg_element("g");
      g0 = svg_element("g");
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        id: true,
        class: true,
        style: true,
        viewBox: true,
        "aria-hidden": true,
        role: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      if (if_block0) if_block0.l(svg_nodes);
      g1 = claim_svg_element(svg_nodes, "g", {
        transform: true,
        "transform-origin": true
      });
      var g1_nodes = children(g1);
      g0 = claim_svg_element(g1_nodes, "g", { transform: true });
      var g0_nodes = children(g0);
      if_block1.l(g0_nodes);
      g0_nodes.forEach(detach_dev);
      g1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        g0,
        "transform",
        /*transform*/
        ctx[16]
      );
      add_location(g0, file, 59, 6, 1699);
      attr_dev(g1, "transform", g1_transform_value = "translate(" + /*i*/
      ctx[17][0] / 2 + " " + /*i*/
      ctx[17][1] / 2 + ")");
      attr_dev(g1, "transform-origin", g1_transform_origin_value = /*i*/
      ctx[17][0] / 4 + " 0");
      add_location(g1, file, 58, 4, 1612);
      attr_dev(
        svg,
        "id",
        /*id*/
        ctx[1]
      );
      attr_dev(svg, "class", svg_class_value = "svelte-fa svelte-fa-base " + /*clazz*/
      ctx[0] + " svelte-bvo74f");
      attr_dev(
        svg,
        "style",
        /*style*/
        ctx[2]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + /*i*/
      ctx[17][0] + " " + /*i*/
      ctx[17][1]);
      attr_dev(svg, "aria-hidden", svg_aria_hidden_value = /*title*/
      ctx[3] === void 0);
      attr_dev(svg, "role", "img");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      toggle_class(
        svg,
        "pulse",
        /*pulse*/
        ctx[9]
      );
      toggle_class(
        svg,
        "svelte-fa-size-lg",
        /*size*/
        ctx[4] === "lg"
      );
      toggle_class(
        svg,
        "svelte-fa-size-sm",
        /*size*/
        ctx[4] === "sm"
      );
      toggle_class(
        svg,
        "svelte-fa-size-xs",
        /*size*/
        ctx[4] === "xs"
      );
      toggle_class(
        svg,
        "svelte-fa-fw",
        /*fw*/
        ctx[6]
      );
      toggle_class(
        svg,
        "svelte-fa-pull-left",
        /*pull*/
        ctx[7] === "left"
      );
      toggle_class(
        svg,
        "svelte-fa-pull-right",
        /*pull*/
        ctx[7] === "right"
      );
      toggle_class(
        svg,
        "spin",
        /*spin*/
        ctx[8]
      );
      add_location(svg, file, 36, 2, 1011);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block0) if_block0.m(svg, null);
      append_hydration_dev(svg, g1);
      append_hydration_dev(g1, g0);
      if_block1.m(g0, null);
      ctx[24](svg);
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(svg, g1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(g0, null);
        }
      }
      if (dirty & /*transform*/
      65536) {
        attr_dev(
          g0,
          "transform",
          /*transform*/
          ctx2[16]
        );
      }
      if (dirty & /*i*/
      131072 && g1_transform_value !== (g1_transform_value = "translate(" + /*i*/
      ctx2[17][0] / 2 + " " + /*i*/
      ctx2[17][1] / 2 + ")")) {
        attr_dev(g1, "transform", g1_transform_value);
      }
      if (dirty & /*i*/
      131072 && g1_transform_origin_value !== (g1_transform_origin_value = /*i*/
      ctx2[17][0] / 4 + " 0")) {
        attr_dev(g1, "transform-origin", g1_transform_origin_value);
      }
      if (dirty & /*id*/
      2) {
        attr_dev(
          svg,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (dirty & /*clazz*/
      1 && svg_class_value !== (svg_class_value = "svelte-fa svelte-fa-base " + /*clazz*/
      ctx2[0] + " svelte-bvo74f")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*style*/
      4) {
        attr_dev(
          svg,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (dirty & /*i*/
      131072 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*i*/
      ctx2[17][0] + " " + /*i*/
      ctx2[17][1])) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (dirty & /*title*/
      8 && svg_aria_hidden_value !== (svg_aria_hidden_value = /*title*/
      ctx2[3] === void 0)) {
        attr_dev(svg, "aria-hidden", svg_aria_hidden_value);
      }
      if (dirty & /*clazz, pulse*/
      513) {
        toggle_class(
          svg,
          "pulse",
          /*pulse*/
          ctx2[9]
        );
      }
      if (dirty & /*clazz, size*/
      17) {
        toggle_class(
          svg,
          "svelte-fa-size-lg",
          /*size*/
          ctx2[4] === "lg"
        );
      }
      if (dirty & /*clazz, size*/
      17) {
        toggle_class(
          svg,
          "svelte-fa-size-sm",
          /*size*/
          ctx2[4] === "sm"
        );
      }
      if (dirty & /*clazz, size*/
      17) {
        toggle_class(
          svg,
          "svelte-fa-size-xs",
          /*size*/
          ctx2[4] === "xs"
        );
      }
      if (dirty & /*clazz, fw*/
      65) {
        toggle_class(
          svg,
          "svelte-fa-fw",
          /*fw*/
          ctx2[6]
        );
      }
      if (dirty & /*clazz, pull*/
      129) {
        toggle_class(
          svg,
          "svelte-fa-pull-left",
          /*pull*/
          ctx2[7] === "left"
        );
      }
      if (dirty & /*clazz, pull*/
      129) {
        toggle_class(
          svg,
          "svelte-fa-pull-right",
          /*pull*/
          ctx2[7] === "right"
        );
      }
      if (dirty & /*clazz, spin*/
      257) {
        toggle_class(
          svg,
          "spin",
          /*spin*/
          ctx2[8]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block0) if_block0.d();
      if_block1.d();
      ctx[24](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(35:0) {#if i[4]}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[3]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file, 56, 6, 1575);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      8) set_data_dev(
        t,
        /*title*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(56:4) {#if title}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let path0;
  let path0_d_value;
  let path0_fill_value;
  let path0_fill_opacity_value;
  let path0_transform_value;
  let path1;
  let path1_d_value;
  let path1_fill_value;
  let path1_fill_opacity_value;
  let path1_transform_value;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        transform: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        transform: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", path0_d_value = /*i*/
      ctx[17][4][0]);
      attr_dev(path0, "fill", path0_fill_value = /*secondaryColor*/
      ctx[11] || /*color*/
      ctx[5] || "currentColor");
      attr_dev(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/
      ctx[14] != false ? (
        /*primaryOpacity*/
        ctx[12]
      ) : (
        /*secondaryOpacity*/
        ctx[13]
      ));
      attr_dev(path0, "transform", path0_transform_value = "translate(" + /*i*/
      ctx[17][0] / -2 + " " + /*i*/
      ctx[17][1] / -2 + ")");
      add_location(path0, file, 68, 10, 1980);
      attr_dev(path1, "d", path1_d_value = /*i*/
      ctx[17][4][1]);
      attr_dev(path1, "fill", path1_fill_value = /*primaryColor*/
      ctx[10] || /*color*/
      ctx[5] || "currentColor");
      attr_dev(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/
      ctx[14] != false ? (
        /*secondaryOpacity*/
        ctx[13]
      ) : (
        /*primaryOpacity*/
        ctx[12]
      ));
      attr_dev(path1, "transform", path1_transform_value = "translate(" + /*i*/
      ctx[17][0] / -2 + " " + /*i*/
      ctx[17][1] / -2 + ")");
      add_location(path1, file, 74, 10, 2237);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*i*/
      131072 && path0_d_value !== (path0_d_value = /*i*/
      ctx2[17][4][0])) {
        attr_dev(path0, "d", path0_d_value);
      }
      if (dirty & /*secondaryColor, color*/
      2080 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/
      ctx2[11] || /*color*/
      ctx2[5] || "currentColor")) {
        attr_dev(path0, "fill", path0_fill_value);
      }
      if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/
      28672 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/
      ctx2[14] != false ? (
        /*primaryOpacity*/
        ctx2[12]
      ) : (
        /*secondaryOpacity*/
        ctx2[13]
      ))) {
        attr_dev(path0, "fill-opacity", path0_fill_opacity_value);
      }
      if (dirty & /*i*/
      131072 && path0_transform_value !== (path0_transform_value = "translate(" + /*i*/
      ctx2[17][0] / -2 + " " + /*i*/
      ctx2[17][1] / -2 + ")")) {
        attr_dev(path0, "transform", path0_transform_value);
      }
      if (dirty & /*i*/
      131072 && path1_d_value !== (path1_d_value = /*i*/
      ctx2[17][4][1])) {
        attr_dev(path1, "d", path1_d_value);
      }
      if (dirty & /*primaryColor, color*/
      1056 && path1_fill_value !== (path1_fill_value = /*primaryColor*/
      ctx2[10] || /*color*/
      ctx2[5] || "currentColor")) {
        attr_dev(path1, "fill", path1_fill_value);
      }
      if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/
      28672 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/
      ctx2[14] != false ? (
        /*secondaryOpacity*/
        ctx2[13]
      ) : (
        /*primaryOpacity*/
        ctx2[12]
      ))) {
        attr_dev(path1, "fill-opacity", path1_fill_opacity_value);
      }
      if (dirty & /*i*/
      131072 && path1_transform_value !== (path1_transform_value = "translate(" + /*i*/
      ctx2[17][0] / -2 + " " + /*i*/
      ctx2[17][1] / -2 + ")")) {
        attr_dev(path1, "transform", path1_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(67:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let path;
  let path_d_value;
  let path_fill_value;
  let path_transform_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true, fill: true, transform: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", path_d_value = /*i*/
      ctx[17][4]);
      attr_dev(path, "fill", path_fill_value = /*color*/
      ctx[5] || /*primaryColor*/
      ctx[10] || "currentColor");
      attr_dev(path, "transform", path_transform_value = "translate(" + /*i*/
      ctx[17][0] / -2 + " " + /*i*/
      ctx[17][1] / -2 + ")");
      add_location(path, file, 61, 10, 1763);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*i*/
      131072 && path_d_value !== (path_d_value = /*i*/
      ctx2[17][4])) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*color, primaryColor*/
      1056 && path_fill_value !== (path_fill_value = /*color*/
      ctx2[5] || /*primaryColor*/
      ctx2[10] || "currentColor")) {
        attr_dev(path, "fill", path_fill_value);
      }
      if (dirty & /*i*/
      131072 && path_transform_value !== (path_transform_value = "translate(" + /*i*/
      ctx2[17][0] / -2 + " " + /*i*/
      ctx2[17][1] / -2 + ")")) {
        attr_dev(path, "transform", path_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: '(61:8) {#if typeof i[4] == \\"string\\"}',
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = (
    /*i*/
    ctx[17][4] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*i*/
        ctx2[17][4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let i;
  let transform;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fa", slots, []);
  let { class: clazz = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { icon } = $$props;
  let { title = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { fw = false } = $$props;
  let { pull = void 0 } = $$props;
  let { scale = 1 } = $$props;
  let { translateX = 0 } = $$props;
  let { translateY = 0 } = $$props;
  let { rotate = void 0 } = $$props;
  let { flip = void 0 } = $$props;
  let { spin = false } = $$props;
  let { pulse = false } = $$props;
  let { primaryColor = "" } = $$props;
  let { secondaryColor = "" } = $$props;
  let { primaryOpacity = 1 } = $$props;
  let { secondaryOpacity = 0.4 } = $$props;
  let { swapOpacity = false } = $$props;
  let svgElement;
  $$self.$$.on_mount.push(function() {
    if (icon === void 0 && !("icon" in $$props || $$self.$$.bound[$$self.$$.props["icon"]])) {
      console.warn("<Fa> was created without expected prop 'icon'");
    }
  });
  const writable_props = [
    "class",
    "id",
    "style",
    "icon",
    "title",
    "size",
    "color",
    "fw",
    "pull",
    "scale",
    "translateX",
    "translateY",
    "rotate",
    "flip",
    "spin",
    "pulse",
    "primaryColor",
    "secondaryColor",
    "primaryOpacity",
    "secondaryOpacity",
    "swapOpacity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Fa> was created with unknown prop '${key}'`);
  });
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      svgElement = $$value;
      $$invalidate(15, svgElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2) $$invalidate(0, clazz = $$props2.class);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2) $$invalidate(2, style = $$props2.style);
    if ("icon" in $$props2) $$invalidate(18, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(3, title = $$props2.title);
    if ("size" in $$props2) $$invalidate(4, size = $$props2.size);
    if ("color" in $$props2) $$invalidate(5, color = $$props2.color);
    if ("fw" in $$props2) $$invalidate(6, fw = $$props2.fw);
    if ("pull" in $$props2) $$invalidate(7, pull = $$props2.pull);
    if ("scale" in $$props2) $$invalidate(19, scale = $$props2.scale);
    if ("translateX" in $$props2) $$invalidate(20, translateX = $$props2.translateX);
    if ("translateY" in $$props2) $$invalidate(21, translateY = $$props2.translateY);
    if ("rotate" in $$props2) $$invalidate(22, rotate = $$props2.rotate);
    if ("flip" in $$props2) $$invalidate(23, flip = $$props2.flip);
    if ("spin" in $$props2) $$invalidate(8, spin = $$props2.spin);
    if ("pulse" in $$props2) $$invalidate(9, pulse = $$props2.pulse);
    if ("primaryColor" in $$props2) $$invalidate(10, primaryColor = $$props2.primaryColor);
    if ("secondaryColor" in $$props2) $$invalidate(11, secondaryColor = $$props2.secondaryColor);
    if ("primaryOpacity" in $$props2) $$invalidate(12, primaryOpacity = $$props2.primaryOpacity);
    if ("secondaryOpacity" in $$props2) $$invalidate(13, secondaryOpacity = $$props2.secondaryOpacity);
    if ("swapOpacity" in $$props2) $$invalidate(14, swapOpacity = $$props2.swapOpacity);
  };
  $$self.$capture_state = () => ({
    getTransform,
    setCustomFontSize,
    clazz,
    id,
    style,
    icon,
    title,
    size,
    color,
    fw,
    pull,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    spin,
    pulse,
    primaryColor,
    secondaryColor,
    primaryOpacity,
    secondaryOpacity,
    swapOpacity,
    svgElement,
    transform,
    i
  });
  $$self.$inject_state = ($$props2) => {
    if ("clazz" in $$props2) $$invalidate(0, clazz = $$props2.clazz);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2) $$invalidate(2, style = $$props2.style);
    if ("icon" in $$props2) $$invalidate(18, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(3, title = $$props2.title);
    if ("size" in $$props2) $$invalidate(4, size = $$props2.size);
    if ("color" in $$props2) $$invalidate(5, color = $$props2.color);
    if ("fw" in $$props2) $$invalidate(6, fw = $$props2.fw);
    if ("pull" in $$props2) $$invalidate(7, pull = $$props2.pull);
    if ("scale" in $$props2) $$invalidate(19, scale = $$props2.scale);
    if ("translateX" in $$props2) $$invalidate(20, translateX = $$props2.translateX);
    if ("translateY" in $$props2) $$invalidate(21, translateY = $$props2.translateY);
    if ("rotate" in $$props2) $$invalidate(22, rotate = $$props2.rotate);
    if ("flip" in $$props2) $$invalidate(23, flip = $$props2.flip);
    if ("spin" in $$props2) $$invalidate(8, spin = $$props2.spin);
    if ("pulse" in $$props2) $$invalidate(9, pulse = $$props2.pulse);
    if ("primaryColor" in $$props2) $$invalidate(10, primaryColor = $$props2.primaryColor);
    if ("secondaryColor" in $$props2) $$invalidate(11, secondaryColor = $$props2.secondaryColor);
    if ("primaryOpacity" in $$props2) $$invalidate(12, primaryOpacity = $$props2.primaryOpacity);
    if ("secondaryOpacity" in $$props2) $$invalidate(13, secondaryOpacity = $$props2.secondaryOpacity);
    if ("swapOpacity" in $$props2) $$invalidate(14, swapOpacity = $$props2.swapOpacity);
    if ("svgElement" in $$props2) $$invalidate(15, svgElement = $$props2.svgElement);
    if ("transform" in $$props2) $$invalidate(16, transform = $$props2.transform);
    if ("i" in $$props2) $$invalidate(17, i = $$props2.i);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*svgElement, size*/
    32784) {
      $: if (svgElement && size) {
        setCustomFontSize(svgElement, size);
      }
    }
    if ($$self.$$.dirty & /*icon*/
    262144) {
      $: $$invalidate(17, i = icon && icon.icon || [0, 0, "", [], ""]);
    }
    if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/
    16252928) {
      $: $$invalidate(16, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
    }
  };
  return [
    clazz,
    id,
    style,
    title,
    size,
    color,
    fw,
    pull,
    spin,
    pulse,
    primaryColor,
    secondaryColor,
    primaryOpacity,
    secondaryOpacity,
    swapOpacity,
    svgElement,
    transform,
    i,
    icon,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    svg_binding
  ];
}
var Fa = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        class: 0,
        id: 1,
        style: 2,
        icon: 18,
        title: 3,
        size: 4,
        color: 5,
        fw: 6,
        pull: 7,
        scale: 19,
        translateX: 20,
        translateY: 21,
        rotate: 22,
        flip: 23,
        spin: 8,
        pulse: 9,
        primaryColor: 10,
        secondaryColor: 11,
        primaryOpacity: 12,
        secondaryOpacity: 13,
        swapOpacity: 14
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fa",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fw() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fw(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pull() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pull(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateX() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateX(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateY() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateY(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotate() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotate(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryColor() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryColor(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryColor() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryColor(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swapOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swapOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fa_default = Fa;

// node_modules/svelte-fa/dist/fa-layers.svelte
var file2 = "node_modules/svelte-fa/dist/fa-layers.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1sinijc", ".svelte-fa-layers.svelte-1sinijc{display:inline-block;position:relative}.svelte-fa-layers.svelte-1sinijc .svelte-fa{position:absolute;bottom:0;left:0;right:0;top:0;margin:auto;text-align:center}.svelte-fa-layers.svelte-1sinijc .svelte-fa-layers-text{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.svelte-fa-layers.svelte-1sinijc .svelte-fa-layers-text span{display:inline-block}.svelte-fa-pull-left.svelte-1sinijc{float:left}.svelte-fa-pull-right.svelte-1sinijc{float:right}.svelte-fa-size-lg.svelte-1sinijc{font-size:1.33333em;line-height:0.75em;vertical-align:-0.225em}.svelte-fa-size-sm.svelte-1sinijc{font-size:0.875em}.svelte-fa-size-xs.svelte-1sinijc{font-size:0.75em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmEtbGF5ZXJzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvVXNlcnMvZ3NrL2hlcm9lc19vZl90aGVfYnJhaW5fd2Vic2l0ZS9ub2RlX21vZHVsZXMvc3ZlbHRlLWZhL2Rpc3QvZmEtbGF5ZXJzLnN2ZWx0ZSJdfQ== */");
}
function create_fragment2(ctx) {
  let span;
  let span_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { id: true, class: true, style: true });
      var span_nodes = children(span);
      if (default_slot) default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "id",
        /*id*/
        ctx[1]
      );
      attr_dev(span, "class", span_class_value = "svelte-fa-layers svelte-fa-base svelte-fa-fw " + /*clazz*/
      ctx[0] + " svelte-1sinijc");
      attr_dev(
        span,
        "style",
        /*style*/
        ctx[2]
      );
      toggle_class(
        span,
        "svelte-fa-pull-left",
        /*pull*/
        ctx[4] === "left"
      );
      toggle_class(
        span,
        "svelte-fa-pull-right",
        /*pull*/
        ctx[4] === "right"
      );
      toggle_class(
        span,
        "svelte-fa-size-lg",
        /*size*/
        ctx[3] === "lg"
      );
      toggle_class(
        span,
        "svelte-fa-size-sm",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        span,
        "svelte-fa-size-xs",
        /*size*/
        ctx[3] === "xs"
      );
      add_location(span, file2, 15, 0, 437);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[8](span);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      2) {
        attr_dev(
          span,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*clazz*/
      1 && span_class_value !== (span_class_value = "svelte-fa-layers svelte-fa-base svelte-fa-fw " + /*clazz*/
      ctx2[0] + " svelte-1sinijc")) {
        attr_dev(span, "class", span_class_value);
      }
      if (!current || dirty & /*style*/
      4) {
        attr_dev(
          span,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*clazz, pull*/
      17) {
        toggle_class(
          span,
          "svelte-fa-pull-left",
          /*pull*/
          ctx2[4] === "left"
        );
      }
      if (!current || dirty & /*clazz, pull*/
      17) {
        toggle_class(
          span,
          "svelte-fa-pull-right",
          /*pull*/
          ctx2[4] === "right"
        );
      }
      if (!current || dirty & /*clazz, size*/
      9) {
        toggle_class(
          span,
          "svelte-fa-size-lg",
          /*size*/
          ctx2[3] === "lg"
        );
      }
      if (!current || dirty & /*clazz, size*/
      9) {
        toggle_class(
          span,
          "svelte-fa-size-sm",
          /*size*/
          ctx2[3] === "sm"
        );
      }
      if (!current || dirty & /*clazz, size*/
      9) {
        toggle_class(
          span,
          "svelte-fa-size-xs",
          /*size*/
          ctx2[3] === "xs"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[8](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fa_layers", slots, ["default"]);
  let { class: clazz = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { pull = void 0 } = $$props;
  let containerElement;
  const writable_props = ["class", "id", "style", "size", "pull"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Fa_layers> was created with unknown prop '${key}'`);
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(5, containerElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2) $$invalidate(0, clazz = $$props2.class);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2) $$invalidate(2, style = $$props2.style);
    if ("size" in $$props2) $$invalidate(3, size = $$props2.size);
    if ("pull" in $$props2) $$invalidate(4, pull = $$props2.pull);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setCustomFontSize,
    clazz,
    id,
    style,
    size,
    pull,
    containerElement
  });
  $$self.$inject_state = ($$props2) => {
    if ("clazz" in $$props2) $$invalidate(0, clazz = $$props2.clazz);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2) $$invalidate(2, style = $$props2.style);
    if ("size" in $$props2) $$invalidate(3, size = $$props2.size);
    if ("pull" in $$props2) $$invalidate(4, pull = $$props2.pull);
    if ("containerElement" in $$props2) $$invalidate(5, containerElement = $$props2.containerElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*containerElement, size*/
    40) {
      $: if (containerElement && size) {
        setCustomFontSize(containerElement, size);
      }
    }
  };
  return [clazz, id, style, size, pull, containerElement, $$scope, slots, span_binding];
}
var Fa_layers = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        class: 0,
        id: 1,
        style: 2,
        size: 3,
        pull: 4
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fa_layers",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pull() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pull(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fa_layers_default = Fa_layers;

// node_modules/svelte-fa/dist/fa-layers-text.svelte
var file3 = "node_modules/svelte-fa/dist/fa-layers-text.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1x0c3df", ".container.svelte-1x0c3df{display:inline-block;height:auto}.svelte-fa-size-lg.svelte-1x0c3df{font-size:1.33333em;line-height:0.75em;vertical-align:-0.225em}.svelte-fa-size-sm.svelte-1x0c3df{font-size:0.875em}.svelte-fa-size-xs.svelte-1x0c3df{font-size:0.75em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmEtbGF5ZXJzLXRleHQuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9nc2svaGVyb2VzX29mX3RoZV9icmFpbl93ZWJzaXRlL25vZGVfbW9kdWxlcy9zdmVsdGUtZmEvZGlzdC9mYS1sYXllcnMtdGV4dC5zdmVsdGUiXX0= */");
}
function create_fragment3(ctx) {
  let span1;
  let span0;
  let span1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { id: true, class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true, style: true });
      var span0_nodes = children(span0);
      if (default_slot) default_slot.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "svelte-fa-base container svelte-1x0c3df");
      attr_dev(
        span0,
        "style",
        /*style*/
        ctx[2]
      );
      toggle_class(
        span0,
        "svelte-fa-size-lg",
        /*size*/
        ctx[3] === "lg"
      );
      toggle_class(
        span0,
        "svelte-fa-size-sm",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        span0,
        "svelte-fa-size-xs",
        /*size*/
        ctx[3] === "xs"
      );
      add_location(span0, file3, 31, 2, 892);
      attr_dev(
        span1,
        "id",
        /*id*/
        ctx[1]
      );
      attr_dev(span1, "class", span1_class_value = "svelte-fa-layers-text " + /*clazz*/
      ctx[0] + " svelte-1x0c3df");
      add_location(span1, file3, 29, 0, 729);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      ctx[14](span0);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*style*/
      4) {
        attr_dev(
          span0,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "svelte-fa-size-lg",
          /*size*/
          ctx2[3] === "lg"
        );
      }
      if (!current || dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "svelte-fa-size-sm",
          /*size*/
          ctx2[3] === "sm"
        );
      }
      if (!current || dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "svelte-fa-size-xs",
          /*size*/
          ctx2[3] === "xs"
        );
      }
      if (!current || dirty & /*id*/
      2) {
        attr_dev(
          span1,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*clazz*/
      1 && span1_class_value !== (span1_class_value = "svelte-fa-layers-text " + /*clazz*/
      ctx2[0] + " svelte-1x0c3df")) {
        attr_dev(span1, "class", span1_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[14](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let transform;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fa_layers_text", slots, ["default"]);
  let { class: clazz = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { color = "" } = $$props;
  let { scale = 1 } = $$props;
  let { translateX = 0 } = $$props;
  let { translateY = 0 } = $$props;
  let { rotate = void 0 } = $$props;
  let { flip = void 0 } = $$props;
  let containerElement;
  const writable_props = [
    "class",
    "id",
    "style",
    "size",
    "color",
    "scale",
    "translateX",
    "translateY",
    "rotate",
    "flip"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Fa_layers_text> was created with unknown prop '${key}'`);
  });
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerElement = $$value;
      $$invalidate(4, containerElement), $$invalidate(11, transform), $$invalidate(5, color), $$invalidate(6, scale), $$invalidate(7, translateX), $$invalidate(8, translateY), $$invalidate(9, rotate), $$invalidate(10, flip);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2) $$invalidate(0, clazz = $$props2.class);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2) $$invalidate(2, style = $$props2.style);
    if ("size" in $$props2) $$invalidate(3, size = $$props2.size);
    if ("color" in $$props2) $$invalidate(5, color = $$props2.color);
    if ("scale" in $$props2) $$invalidate(6, scale = $$props2.scale);
    if ("translateX" in $$props2) $$invalidate(7, translateX = $$props2.translateX);
    if ("translateY" in $$props2) $$invalidate(8, translateY = $$props2.translateY);
    if ("rotate" in $$props2) $$invalidate(9, rotate = $$props2.rotate);
    if ("flip" in $$props2) $$invalidate(10, flip = $$props2.flip);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getTransform,
    setCustomFontSize,
    clazz,
    id,
    style,
    size,
    color,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    containerElement,
    transform
  });
  $$self.$inject_state = ($$props2) => {
    if ("clazz" in $$props2) $$invalidate(0, clazz = $$props2.clazz);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2) $$invalidate(2, style = $$props2.style);
    if ("size" in $$props2) $$invalidate(3, size = $$props2.size);
    if ("color" in $$props2) $$invalidate(5, color = $$props2.color);
    if ("scale" in $$props2) $$invalidate(6, scale = $$props2.scale);
    if ("translateX" in $$props2) $$invalidate(7, translateX = $$props2.translateX);
    if ("translateY" in $$props2) $$invalidate(8, translateY = $$props2.translateY);
    if ("rotate" in $$props2) $$invalidate(9, rotate = $$props2.rotate);
    if ("flip" in $$props2) $$invalidate(10, flip = $$props2.flip);
    if ("containerElement" in $$props2) $$invalidate(4, containerElement = $$props2.containerElement);
    if ("transform" in $$props2) $$invalidate(11, transform = $$props2.transform);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/
    1984) {
      $: $$invalidate(11, transform = getTransform(scale, translateX, translateY, rotate, flip, 1, "em", "deg"));
    }
    if ($$self.$$.dirty & /*containerElement, transform*/
    2064) {
      $: if (containerElement) {
        $$invalidate(4, containerElement.style.transform = transform, containerElement);
      }
    }
    if ($$self.$$.dirty & /*containerElement, color*/
    48) {
      $: if (containerElement && color) {
        $$invalidate(4, containerElement.style.color = color, containerElement);
      }
    }
    if ($$self.$$.dirty & /*containerElement, size*/
    24) {
      $: if (containerElement && size) {
        setCustomFontSize(containerElement, size);
      }
    }
  };
  return [
    clazz,
    id,
    style,
    size,
    containerElement,
    color,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    transform,
    $$scope,
    slots,
    span0_binding
  ];
}
var Fa_layers_text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        class: 0,
        id: 1,
        style: 2,
        size: 3,
        color: 5,
        scale: 6,
        translateX: 7,
        translateY: 8,
        rotate: 9,
        flip: 10
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fa_layers_text",
      options,
      id: create_fragment3.name
    });
  }
  get class() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateX() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateX(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateY() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateY(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotate() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotate(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Fa_layers_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Fa_layers_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fa_layers_text_default = Fa_layers_text;

// node_modules/svelte-fa/dist/index.js
var dist_default = fa_default;
export {
  fa_default as Fa,
  fa_layers_default as FaLayers,
  fa_layers_text_default as FaLayersText,
  dist_default as default
};
//# sourceMappingURL=svelte-fa.js.map
